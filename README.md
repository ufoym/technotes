## C++

### `extern`用途
1. `extern` + 变量/函数声明
   * 告诉编译器该变量/函数在后面/其它cpp定义
   * 注意是声明，不要初始化
   * `#include`也可达到同样目的，但`extern`可加速编译
2. `extern "C"` + 函数
   * 告诉链接器用C函数规范来链接，以便在C++中调用C库函数
   * 因C++支持函数重载，函数被C++编译后在符号库中的名字与C不同

### `static`用途
1. 修饰局部变量
   * 使变量存放在静态数据区，生命周期持续到程序结束，作用域不变（仍然是局部变量）
   * 只在初次运行时进行初始化工作，且只进行一次
2. 修饰全局变量/函数
   * 使变量/函数作用域由原来的整个工程可见（用`extern`即可）变为本源文件可见
3. 修饰类成员变量
   * 使变量为所有对象共享，相当于类范围内的全局变量
   * 必须初始化（例如`int A::s_value = 0;`），且将在`main`前执行
4. 修饰类成员函数
   * 相当于类范围内的全局函数
   * 木有this指针，只能访问类的静态成员
   * 实现不需要`static`修饰

### `const`用途
1. 声明常量     
2. 声明函数形参
3. 声明函数返回值
   * 返回指针时，可防止返回的指针内容被修改
   * 按值返回时则没必要加`const`，例如不要写成`const int foo()`
4. 修饰类成员函数
   * 防止成员函数对成员变量进行修改
   * 只能调用类的其它const成员函数
   * 如果要在const成员函数修改某个成员变量，那么可以给这个变量的声明加上`mutable`

### `sizeof`
* 作用：返回一个对象或者类型所占的内存（不计算类/结构体的static成员）
* 如果类中有虚函数，那么最终结果要多加4Byte（多出一个指向虚函数表的指针）
* 对空类使用sizeof会返回1（占用内存为0，无法实例化，所以编译器为了使空类也能实例化，就给其分配了1Byte）
* 例
  ```
  static int a;         //sizeof(a) = 4
   
  class Zero {
  int a;
  static int b;
  virtual void fun() {}
  };                    //sizeof(Zero) = 8
   
  class Lin {
  virtual void fun() {}
  };                    //sizeof(Lin) = 4
   
  class Child: public Zero {
       int a;
       virtual void fun() {}
  };                    //sizeof(Child) = 12
  ```
